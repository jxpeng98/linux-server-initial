#!/bin/bash
# manage_nginx_service.sh
# 管理 nginx 反向代理服务（添加/删除/列出后端服务）
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# 引入公共函数
# shellcheck source=common.sh
. "${SCRIPT_DIR}/common.sh"

init_lang
ensure_root

# 配置文件路径
NGINX_CONF_DIR="/etc/nginx/sites-available"
NGINX_CONF_ENABLED="/etc/nginx/sites-enabled"
CONF_NAME="cloudflare-proxy"
CONF_FILE="${NGINX_CONF_DIR}/${CONF_NAME}"
SERVICES_DIR="/etc/nginx/proxy-services.d"

# ============================================
# 辅助函数
# ============================================

# 检查 nginx 是否已配置
check_nginx_setup() {
  if [ ! -f "$CONF_FILE" ]; then
    msg "${RED}错误: nginx 代理尚未配置。请先运行 setup_nginx_proxy.sh${NC}" \
        "${RED}Error: nginx proxy not configured. Please run setup_nginx_proxy.sh first${NC}"
    exit 1
  fi
}

# 确保服务配置目录存在
ensure_services_dir() {
  if [ ! -d "$SERVICES_DIR" ]; then
    mkdir -p "$SERVICES_DIR"
    log_info "Created services directory: $SERVICES_DIR"
  fi
}

# 生成 location 配置块（基于路径）
generate_location_block() {
  local path="$1"
  local target="$2"
  local websocket="${3:-yes}"
  
  local ws_headers=""
  if [[ "$websocket" =~ ^[Yy] ]]; then
    ws_headers='
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";'
  fi

  cat << EOF
    location ${path} {
        proxy_pass ${target};${ws_headers}
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header CF-Connecting-IP \$http_cf_connecting_ip;
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        proxy_buffering off;
    }
EOF
}

# 生成 server 块配置（基于域名）
generate_server_block() {
  local hostname="$1"
  local target="$2"
  local listen_port="$3"
  local websocket="${4:-yes}"
  
  local ws_headers=""
  if [[ "$websocket" =~ ^[Yy] ]]; then
    ws_headers='
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";'
  fi

  cat << EOF
# Server block for: ${hostname}
server {
    listen 127.0.0.1:${listen_port};
    listen [::1]:${listen_port};
    
    server_name ${hostname};
    
    # 日志
    access_log /var/log/nginx/cloudflare-proxy-access.log;
    error_log /var/log/nginx/cloudflare-proxy-error.log;
    
    # 安全头
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # Cloudflare 相关头
    real_ip_header CF-Connecting-IP;
    
    location / {
        proxy_pass ${target};${ws_headers}
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header CF-Connecting-IP \$http_cf_connecting_ip;
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        proxy_buffering off;
    }
}
EOF
}

# 从配置文件中提取监听端口
get_listen_port() {
  grep -oP 'listen 127\.0\.0\.1:\K[0-9]+' "$CONF_FILE" 2>/dev/null | head -1 || echo "9999"
}

# 重新生成主配置文件（从服务片段）
regenerate_main_config() {
  local listen_port
  listen_port=$(get_listen_port)
  
  # 分离基于路径和基于域名的服务
  local location_blocks=""
  local server_blocks=""
  
  if [ -d "$SERVICES_DIR" ] && [ "$(ls -A "$SERVICES_DIR" 2>/dev/null)" ]; then
    for service_file in "$SERVICES_DIR"/*.conf; do
      if [ -f "$service_file" ]; then
        # 检查服务类型
        if grep -q "^# Type: Path-based" "$service_file"; then
          # 基于路径的服务 - 添加到主 server 的 location 块
          location_blocks+="$(grep -A 999 "^    location" "$service_file" || cat "$service_file")"
          location_blocks+=$'\n'
        elif grep -q "^# Type: Domain-based" "$service_file"; then
          # 基于域名的服务 - 添加为独立 server 块
          server_blocks+="$(grep -A 999 "^server {" "$service_file" || cat "$service_file")"
          server_blocks+=$'\n'
        else
          # 兼容旧格式（无类型标记）- 默认为基于路径
          location_blocks+="$(cat "$service_file")"
          location_blocks+=$'\n'
        fi
      fi
    done
  fi
  
  # 生成主配置（包含默认 server 和独立 server 块）
  cat > "$CONF_FILE" << EOF
# Nginx reverse proxy for Cloudflare Zero Trust
# Generated by linux-server-initial on $(date '+%Y-%m-%d %H:%M:%S')
# Listen on localhost:${listen_port} for Cloudflare Tunnel
# 
# Service configurations are stored in: ${SERVICES_DIR}/

# Default server block (for path-based routing)
server {
    listen 127.0.0.1:${listen_port} default_server;
    listen [::1]:${listen_port} default_server;
    
    server_name _;
    
    # 日志
    access_log /var/log/nginx/cloudflare-proxy-access.log;
    error_log /var/log/nginx/cloudflare-proxy-error.log;
    
    # 安全头
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # Cloudflare 相关头
    real_ip_header CF-Connecting-IP;
    
    # 健康检查端点
    location /health {
        access_log off;
        return 200 "OK\\n";
        add_header Content-Type text/plain;
    }
${location_blocks}
}

# Domain-based server blocks
${server_blocks}
EOF
}

# 测试并重载 nginx
reload_nginx() {
  msg "测试 nginx 配置..." "Testing nginx configuration..."
  if nginx -t 2>&1; then
    msg "${GREEN}配置测试通过${NC}" "${GREEN}Configuration test passed${NC}"
    systemctl reload nginx || systemctl restart nginx
    msg "${GREEN}nginx 已重载${NC}" "${GREEN}nginx reloaded${NC}"
    log_info "nginx reloaded successfully"
    return 0
  else
    msg "${RED}配置测试失败！${NC}" "${RED}Configuration test failed!${NC}"
    log_error "nginx config test failed"
    return 1
  fi
}

# ============================================
# 添加服务
# ============================================
add_service() {
  check_nginx_setup
  ensure_services_dir
  
  msg "${GREEN}=== 添加新的代理服务 ===${NC}" "${GREEN}=== Add New Proxy Service ===${NC}"
  echo ""
  
  # 选择配置类型
  if is_en; then
    echo "Service type:"
    echo "  1) Path-based routing (e.g., /api, /app) - share same domain"
    echo "  2) Domain-based routing (e.g., gitea.domain.com) - separate domains"
    read -rp "Select type [1/2]: " SERVICE_TYPE
  else
    echo "服务类型："
    echo "  1) 基于路径的路由 (如 /api, /app) - 共用同一域名"
    echo "  2) 基于域名的路由 (如 gitea.domain.com) - 独立域名"
    read -rp "请选择类型 [1/2]: " SERVICE_TYPE
  fi
  
  SERVICE_TYPE="${SERVICE_TYPE:-1}"
  
  # 服务名称
  prompt_read "服务名称 (用于标识，如 myapp): " \
              "Service name (for identification, e.g., myapp): " \
              "" SERVICE_NAME
  
  if [ -z "$SERVICE_NAME" ]; then
    msg "${RED}服务名称不能为空${NC}" "${RED}Service name cannot be empty${NC}"
    exit 1
  fi
  
  # 规范化名称（只允许字母数字和连字符）
  SERVICE_NAME=$(echo "$SERVICE_NAME" | tr -cd 'a-zA-Z0-9-' | tr '[:upper:]' '[:lower:]')
  SERVICE_FILE="${SERVICES_DIR}/${SERVICE_NAME}.conf"
  
  if [ -f "$SERVICE_FILE" ]; then
    msg "${YELLOW}服务 '${SERVICE_NAME}' 已存在${NC}" "${YELLOW}Service '${SERVICE_NAME}' already exists${NC}"
    prompt_read "是否覆盖? [y/N]: " "Overwrite? [y/N]: " "n" OVERWRITE
    if [[ ! "$OVERWRITE" =~ ^[Yy]$ ]]; then
      msg "已取消" "Cancelled"
      exit 0
    fi
  fi
  
  # 根据类型配置
  if [ "$SERVICE_TYPE" = "1" ]; then
    # 基于路径
    prompt_read "URL 路径 (如 / 或 /api 或 /app): " \
                "URL path (e.g., / or /api or /app): " \
                "/" PROXY_PATH
    
    PROXY_DOMAIN=""
  else
    # 基于域名
    prompt_read "域名 (如 app.yourdomain.com): " \
                "Domain name (e.g., app.yourdomain.com): " \
                "" PROXY_DOMAIN
    
    if [ -z "$PROXY_DOMAIN" ]; then
      msg "${RED}域名不能为空${NC}" "${RED}Domain name cannot be empty${NC}"
      exit 1
    fi
    
    PROXY_PATH="/"
  fi
  
  # 后端地址
  prompt_read "后端服务地址 (如 http://127.0.0.1:3000): " \
              "Backend service address (e.g., http://127.0.0.1:3000): " \
              "" PROXY_TARGET
  
  if [ -z "$PROXY_TARGET" ]; then
    msg "${RED}后端地址不能为空${NC}" "${RED}Backend address cannot be empty${NC}"
    exit 1
  fi
  
  # WebSocket 支持
  prompt_read "是否需要 WebSocket 支持? [Y/n]: " \
              "Enable WebSocket support? [Y/n]: " \
              "y" WEBSOCKET
  
  # 生成服务配置
  local listen_port
  listen_port=$(get_listen_port)
  
  if [ "$SERVICE_TYPE" = "1" ]; then
    # 基于路径的配置（添加到主 server 块）
    cat > "$SERVICE_FILE" << EOF
# Service: ${SERVICE_NAME}
# Type: Path-based
# Path: ${PROXY_PATH} -> ${PROXY_TARGET}
# Created: $(date '+%Y-%m-%d %H:%M:%S')
$(generate_location_block "$PROXY_PATH" "$PROXY_TARGET" "$WEBSOCKET")
EOF
    log_info "Added path-based service: ${SERVICE_NAME} (${PROXY_PATH} -> ${PROXY_TARGET})"
  else
    # 基于域名的配置（独立 server 块）
    cat > "$SERVICE_FILE" << EOF
# Service: ${SERVICE_NAME}
# Type: Domain-based
# Domain: ${PROXY_DOMAIN} -> ${PROXY_TARGET}
# Created: $(date '+%Y-%m-%d %H:%M:%S')
$(generate_server_block "$PROXY_DOMAIN" "$PROXY_TARGET" "$listen_port" "$WEBSOCKET")
EOF
    log_info "Added domain-based service: ${SERVICE_NAME} (${PROXY_DOMAIN} -> ${PROXY_TARGET})"
  fi
  
  # 重新生成主配置
  regenerate_main_config
  
  # 重载 nginx
  if reload_nginx; then
    echo ""
    msg "${GREEN}✅ 服务 '${SERVICE_NAME}' 添加成功${NC}" \
        "${GREEN}✅ Service '${SERVICE_NAME}' added successfully${NC}"
    echo ""
    if [ "$SERVICE_TYPE" = "1" ]; then
      msg "访问地址: http://127.0.0.1:${listen_port}${PROXY_PATH}" \
          "Access URL: http://127.0.0.1:${listen_port}${PROXY_PATH}"
    else
      msg "域名: ${PROXY_DOMAIN}" "Domain: ${PROXY_DOMAIN}"
      msg "${YELLOW}Cloudflare Tunnel 配置:${NC}" "${YELLOW}Cloudflare Tunnel Config:${NC}"
      if is_en; then
        echo "  The tunnel should forward ALL domains to:"
        echo "  → http://127.0.0.1:${listen_port}"
        echo ""
        echo "  Nginx will automatically route by domain name."
        echo "  No additional Cloudflare config needed for each service."
      else
        echo "  Tunnel 应该将所有域名统一转发到:"
        echo "  → http://127.0.0.1:${listen_port}"
        echo ""
        echo "  Nginx 会根据域名自动分流。"
        echo "  每个服务无需额外的 Cloudflare 配置。"
      fi
    fi
    msg "后端地址: ${PROXY_TARGET}" "Backend: ${PROXY_TARGET}"
  else
    # 回滚
    rm -f "$SERVICE_FILE"
    regenerate_main_config
    msg "${RED}添加失败，已回滚${NC}" "${RED}Failed to add, rolled back${NC}"
    exit 1
  fi
}

# ============================================
# 删除服务
# ============================================
remove_service() {
  check_nginx_setup
  ensure_services_dir
  
  msg "${GREEN}=== 删除代理服务 ===${NC}" "${GREEN}=== Remove Proxy Service ===${NC}"
  echo ""
  
  # 列出现有服务
  if [ ! "$(ls -A "$SERVICES_DIR" 2>/dev/null)" ]; then
    msg "${YELLOW}没有配置任何服务${NC}" "${YELLOW}No services configured${NC}"
    exit 0
  fi
  
  msg "已配置的服务:" "Configured services:"
  local i=1
  local services=()
  for service_file in "$SERVICES_DIR"/*.conf; do
    if [ -f "$service_file" ]; then
      local name
      name=$(basename "$service_file" .conf)
      local info
      info=$(grep "^# Path:" "$service_file" 2>/dev/null | sed 's/^# Path: //' || echo "unknown")
      echo "  $i) $name - $info"
      services+=("$name")
      ((i++))
    fi
  done
  echo ""
  
  prompt_read "输入要删除的服务名称或编号: " \
              "Enter service name or number to remove: " \
              "" INPUT
  
  if [ -z "$INPUT" ]; then
    msg "已取消" "Cancelled"
    exit 0
  fi
  
  # 确定服务名
  local service_to_remove=""
  if [[ "$INPUT" =~ ^[0-9]+$ ]] && [ "$INPUT" -ge 1 ] && [ "$INPUT" -le ${#services[@]} ]; then
    service_to_remove="${services[$((INPUT-1))]}"
  else
    service_to_remove="$INPUT"
  fi
  
  local service_file="${SERVICES_DIR}/${service_to_remove}.conf"
  if [ ! -f "$service_file" ]; then
    msg "${RED}服务 '${service_to_remove}' 不存在${NC}" \
        "${RED}Service '${service_to_remove}' does not exist${NC}"
    exit 1
  fi
  
  prompt_read "确认删除服务 '${service_to_remove}'? [y/N]: " \
              "Confirm remove service '${service_to_remove}'? [y/N]: " \
              "n" CONFIRM
  
  if [[ ! "$CONFIRM" =~ ^[Yy]$ ]]; then
    msg "已取消" "Cancelled"
    exit 0
  fi
  
  # 备份并删除
  cp "$service_file" "${service_file}.bak.$(date +%F-%H%M%S)"
  rm -f "$service_file"
  
  log_info "Removed service: ${service_to_remove}"
  
  # 重新生成主配置
  regenerate_main_config
  
  if reload_nginx; then
    msg "${GREEN}✅ 服务 '${service_to_remove}' 已删除${NC}" \
        "${GREEN}✅ Service '${service_to_remove}' removed${NC}"
  fi
}

# ============================================
# 列出服务
# ============================================
list_services() {
  check_nginx_setup
  ensure_services_dir
  
  local listen_port
  listen_port=$(get_listen_port)
  
  echo ""
  msg "${GREEN}=== Nginx 代理服务列表 ===${NC}" "${GREEN}=== Nginx Proxy Services ===${NC}"
  echo ""
  msg "监听地址: 127.0.0.1:${listen_port}" "Listen address: 127.0.0.1:${listen_port}"
  msg "配置文件: ${CONF_FILE}" "Config file: ${CONF_FILE}"
  echo ""
  
  if [ ! "$(ls -A "$SERVICES_DIR" 2>/dev/null)" ]; then
    msg "${YELLOW}没有配置任何服务${NC}" "${YELLOW}No services configured${NC}"
    echo ""
    msg "使用 '$0 add' 添加新服务" "Use '$0 add' to add a new service"
    exit 0
  fi
  
  msg "已配置的服务:" "Configured services:"
  echo ""
  printf "  %-15s %-10s %-25s %s\n" "服务名/Name" "类型/Type" "路径或域名/Path or Domain" "后端/Backend"
  printf "  %-15s %-10s %-25s %s\n" "-----------" "--------" "---------------------" "-----------"
  
  for service_file in "$SERVICES_DIR"/*.conf; do
    if [ -f "$service_file" ]; then
      local name
      name=$(basename "$service_file" .conf)
      local type
      local route
      local backend
      
      if grep -q "^# Type: Domain-based" "$service_file"; then
        type="Domain"
        route=$(grep -oP '(?<=server_name )[^;]+' "$service_file" 2>/dev/null | head -1 || echo "?")
      else
        type="Path"
        route=$(grep -oP '(?<=location )[^ ]+' "$service_file" 2>/dev/null | head -1 || echo "?")
      fi
      
      backend=$(grep -oP '(?<=proxy_pass )[^;]+' "$service_file" 2>/dev/null | head -1 || echo "?")
      printf "  %-15s %-10s %-25s %s\n" "$name" "$type" "$route" "$backend"
    fi
  done
  echo ""
  
  # 显示健康检查
  msg "健康检查: http://127.0.0.1:${listen_port}/health" \
      "Health check: http://127.0.0.1:${listen_port}/health"
  echo ""
}

# ============================================
# 显示帮助
# ============================================
show_help() {
  echo ""
  msg "${GREEN}Nginx 代理服务管理工具${NC}" "${GREEN}Nginx Proxy Service Manager${NC}"
  echo ""
  msg "用法: $0 <命令>" "Usage: $0 <command>"
  echo ""
  msg "命令:" "Commands:"
  echo "  add     - 添加新的代理服务 / Add a new proxy service"
  echo "  remove  - 删除代理服务 / Remove a proxy service"
  echo "  list    - 列出所有服务 / List all services"
  echo "  reload  - 重新加载 nginx / Reload nginx"
  echo "  help    - 显示帮助 / Show this help"
  echo ""
  msg "${YELLOW}工作原理:${NC}" "${YELLOW}How it works:${NC}"
  echo ""
  if is_en; then
    cat << 'EOF'
  Internet User
       ↓
  Cloudflare Edge (public)
       ↓ (Cloudflare Tunnel)
  cloudflared (your server)
       ↓ (ALL domains forward to http://127.0.0.1:9999)
  Nginx (listen 127.0.0.1:9999)
       ↓ (route by domain Host header)
  Backend Services:
    service.domain.com → 127.0.0.1:3000 (Your Service)

  Cloudflare Tunnel Config (config.yml or Dashboard):
    ingress:
      - hostname: "*.yourdomain.com"
        service: http://127.0.0.1:9999
      - service: http_status:404
EOF
  else
    cat << 'EOF'
  互联网用户
       ↓
  Cloudflare Edge (公网)
       ↓ (Cloudflare Tunnel 加密隧道)
  cloudflared (你的服务器)
       ↓ (所有域名统一转发到 http://127.0.0.1:9999)
  Nginx (监听 127.0.0.1:9999)
       ↓ (根据域名 Host 头分流)
  后端服务:
    service.domain.com → 127.0.0.1:3000 (你的服务)

  Cloudflare Tunnel 配置 (config.yml 或 Dashboard):
    ingress:
      - hostname: "*.yourdomain.com"
        service: http://127.0.0.1:9999
      - service: http_status:404
EOF
  fi
  echo ""
  msg "${YELLOW}示例:${NC}" "${YELLOW}Examples:${NC}"
  if is_en; then
    echo "  # Add a service (domain-based, recommended)"
    echo "  $0 add"
    echo "    → Service name: myapp"
    echo "    → Type: 2 (domain-based)"
    echo "    → Domain: app.yourdomain.com"
    echo "    → Backend: http://127.0.0.1:3000"
  else
    echo "  # 添加服务（基于域名，推荐）"
    echo "  $0 add"
    echo "    → 服务名称: myapp"
    echo "    → 类型: 2 (基于域名)"
    echo "    → 域名: app.yourdomain.com"
    echo "    → 后端: http://127.0.0.1:3000"
  fi
  echo ""
  echo "  $0 list     # 查看所有已配置的服务 / List all services"
  echo "  $0 remove   # 删除服务 / Remove a service"
  echo ""
}

# ============================================
# 主入口
# ============================================
ACTION="${1:-help}"

case "$ACTION" in
  add|a)
    add_service
    ;;
  remove|rm|delete|del)
    remove_service
    ;;
  list|ls|l)
    list_services
    ;;
  reload|r)
    check_nginx_setup
    reload_nginx
    ;;
  help|h|--help|-h)
    show_help
    ;;
  *)
    msg "${RED}未知命令: $ACTION${NC}" "${RED}Unknown command: $ACTION${NC}"
    show_help
    exit 1
    ;;
esac
